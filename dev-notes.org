* TODO Github Issue #1: Trivial combinational logic [60%]

  Let's start from a very primitive Haskell function:
  #+BEGIN_SRC haskell
    abs :: Word -> Word -> Word
    abs a b | a < b = b - a
            | otherwise = a - b
  #+END_SRC

  Ideally, the Haskell function abs should be compiled to a Verilog
  module
  #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
  #+END_SRC

** DONE Print the desugared bindings of the Haskell source
   CLOSED: [2016-11-07 Mon 17:46]

   ~setSessionDynFlags~ is necessary if there is no dynamic flag to
   set because ~setSessionDynFlags~ will initialize library search
   path.  Otherwise, the GHC session will fail at finding dependent
   modules even as ~Prelude~.
   
   Related articles:
   * GHC compilation process:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain]]
   * The Core data:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType]]

   How to extract the ~CoreExpr~ from the desugared module? ~mg_bind
   :: ModGuts -> CoreProgram~ return the binds. [[http://www.stephendiehl.com/posts/ghc_02.html][Dive Into GHC: The
   2nd article]] has some pretty examples about showing the core
   program.

   * ~HsSyn~ represents the AST parsed from source code.
   * ~coreModule~ extracts ~ModGuts~ from desugered module.
   * ~mg_binds~ return the core program from ~ModGuts~.
** DONE Get Verilog module name from function name
   CLOSED: [2016-11-21 Mon 17:40]

   Get module name ~abc~ from the binding of ~abc~.

   Reviewing GHC's code for pretty-printing ~CoreBind~.

   There is:
   #+BEGIN_SRC haskell
     pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
   #+END_SRC
   to do pretty-printing for expressions. But pretty-printing ~Expr~
   doesn't show the function name.

   It is the binding variable ~v~ in a ~NonRec v e~ that shows the
   naming "abs". ~getOccString~ retrieve the string in ~v~.
** TODO Get the input output ports for the Verilog module
   
   Functions are represented as curried lambda expressions.
   So for ~abs~, its curried form is:
   #+BEGIN_SRC haskell
     abs = \a -> (\b -> case a < b of
                          True -> b - a
                          otherwise -> a - b)
   #+END_SRC
   And the lambda expressions are translated directly to ~Core.Lam v
   e~, where ~v~ is the variable and ~e~ is the expression.

   So to get all the inputs of a function, the corresponding
   ~Core.Lam~ should be "de-curried", a process to strip off all the
   consequence ~Core.Lam~ expression, and return the list of binders
   of the stripped ~Core.Lam~ and the non-lambda expression it first
   find.

   Once the variable list is "de-curried" out, the bit-width 
   of the Verilog module inputs are determined by the type information
   of the variables.
*** DONE To determine the bit-width for a binder ~Word~
    CLOSED: [2016-12-08 Thu 17:09]
    #+BEGIN_SRC haskell
    varType :: Var -> Kind
    #+END_SRC
    retrieve the type of the binder (~Kind~ is a synonym of ~Type~).
    
    #+BEGIN_SRC haskell
    splitTyConApp_maybe :: Type -> Maybe (TyCon, [Type])
    #+END_SRC
    try to split a type into a type constructor and the arguments to
    that constructor, by which type ~Word~ is split into a ~TyCon~ of
    ~Word~ and an empty argument list.

    We can determine how a ~TyCon~ is defined in Haskell, either by
    ~data~, ~type~ or any other constructs, by various predicates.
    For ~Word~, it is defined by ~data~ construct. Then ~isAlgTyCon~
    should return ~True~. 

    ~TyCon~ is an instance of class ~NamedThing~,
    so we can the name string by ~getOccString . getName~. For ~Word~,
    it should return "Word".

    When getting the string "Word", we know it is of type ~Word~, and 
    the bit width is ~finiteBitSize (0::Word)~.
    
   
** DONE Data to represent the verilog netlist
   CLOSED: [2016-10-28 Fri 15:31]
   To design data types to represent a verilog module. The data
   should be an instance of class ~Outputable~, and can be
   pretty-printed into Verilog language.

   As the first step, the data type should be capable of representing
   the target Verilog content.
   #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
   #+END_SRC

   Done with module ~Verilog~ (~Verilog.hs~.)

   
