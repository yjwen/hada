* TODO Github Issue #1: Trivial combinational logic [71%]

  Let's start from a very primitive Haskell function:
  #+BEGIN_SRC haskell
    abs :: Word -> Word -> Word
    abs a b | a < b = b - a
            | otherwise = a - b
  #+END_SRC

  Ideally, the Haskell function abs should be compiled to a Verilog
  module
  #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
  #+END_SRC

** DONE Print the desugared bindings of the Haskell source
   CLOSED: [2016-11-07 Mon 17:46]

   ~setSessionDynFlags~ is necessary if there is no dynamic flag to
   set because ~setSessionDynFlags~ will initialize library search
   path.  Otherwise, the GHC session will fail at finding dependent
   modules even as ~Prelude~.
   
   Related articles:
   * GHC compilation process:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain]]
   * The Core data:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType]]

   How to extract the ~CoreExpr~ from the desugared module? ~mg_bind
   :: ModGuts -> CoreProgram~ return the binds. [[http://www.stephendiehl.com/posts/ghc_02.html][Dive Into GHC: The
   2nd article]] has some pretty examples about showing the core
   program.

   * ~HsSyn~ represents the AST parsed from source code.
   * ~coreModule~ extracts ~ModGuts~ from desugered module.
   * ~mg_binds~ return the core program from ~ModGuts~.
** DONE Get Verilog module name from function name
   CLOSED: [2016-11-21 Mon 17:40]

   Get module name ~abc~ from the binding of ~abc~.

   Reviewing GHC's code for pretty-printing ~CoreBind~.

   There is:
   #+BEGIN_SRC haskell
     pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
   #+END_SRC
   to do pretty-printing for expressions. But pretty-printing ~Expr~
   doesn't show the function name.

   It is the binding variable ~v~ in a ~NonRec v e~ that shows the
   naming "abs". ~getOccString~ retrieve the string in ~v~.
** DONE Get the input output ports for the Verilog module
   CLOSED: [2016-12-13 Tue 18:15]
   
   Functions are represented as curried lambda expressions.
   So for ~abs~, its curried form is:
   #+BEGIN_SRC haskell
     abs = \a -> (\b -> case a < b of
                          True -> b - a
                          otherwise -> a - b)
   #+END_SRC
   And the lambda expressions are translated directly to ~Core.Lam v
   e~, where ~v~ is the variable and ~e~ is the expression.

   To get all the inputs of a function, the corresponding
   ~Core.Lam~ should be "de-curried", a process to strip off all the
   consequence ~Core.Lam~ expression, and return the list of binders
   of the stripped ~Core.Lam~ and the non-lambda expression it first
   find.

   Once the variable list is "de-curried" out, the bit-width 
   of the Verilog module inputs are determined by the type information
   of the variables. 
*** DONE Determine the bit-width for a binder ~Word~
    CLOSED: [2016-12-08 Thu 17:09]
    #+BEGIN_SRC haskell
    varType :: Var -> Kind
    #+END_SRC
    retrieve the type of the binder (~Kind~ is a synonym of ~Type~).
    
    #+BEGIN_SRC haskell
    splitTyConApp_maybe :: Type -> Maybe (TyCon, [Type])
    #+END_SRC
    try to split a type into a type constructor and the arguments to
    that constructor, by which type ~Word~ is split into a ~TyCon~ of
    ~Word~ and an empty argument list.

    We can determine how a ~TyCon~ is defined in Haskell, either by
    ~data~, ~type~ or any other constructs, by various predicates.
    For ~Word~, it is defined by ~data~ construct. Then ~isAlgTyCon~
    should return ~True~. 

    ~TyCon~ is an instance of class ~NamedThing~,
    so we can the name string by ~getOccString . getName~. For ~Word~,
    it should return "Word".

    When getting the string "Word", we know it is of type ~Word~, and 
    the bit width is ~finiteBitSize (0::Word)~.
    
   
*** DONE Determine the output type of a binding
    CLOSED: [2016-12-13 Tue 18:09]
    
    The type of the bound variable ~v~ in ~NonRec v e~ should be ~Word
    -> Word -> Word~, of kind ~* -> *~.

    The bound variable' type already gives the type of each input
    variable and the type of the returned value, namely the type of
    the output point of the Verilog module to be mapped to.

    We need to de-curry the type of kind ~* -> *~ to a list of types
    of kind ~*~ and return the input type list and the return type.

    There is:
    #+BEGIN_SRC haskell
      splitFunTys :: Type -> ([Type], Type)
    #+END_SRC
    doing such de-currying.
    
** DONE Data to represent the verilog netlist
   CLOSED: [2016-10-28 Fri 15:31]
   To design data types to represent a verilog module. The data
   should be an instance of class ~Outputable~, and can be
   pretty-printed into Verilog language.

   As the first step, the data type should be capable of representing
   the target Verilog content.
   #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
   #+END_SRC

   Done with module ~Verilog~ (~Verilog.hs~.)

** DONE Data structure for control-data-flow-graph

   CLOSED: [2016-12-20 Tue 01:10]
   
   Mapping a case expression from Core.Expr to Verilog condition
   constructs is too complicated, considering the complex pattern
   matching syntax of Haskell is quite different from the syntax of
   various Verilog's conditional constructs.

   An intermediate data structure is necessary to isolate the mapping
   from Haskell case expression to conditional representation, and
   from conditional representation to Verilog conditional constructs.

   Such intermediate data structure is also useful for future optimization
   and scheduling of tasks.

   Take control-data-flow-graph as a start point.

   Finished a CDFG module to represent module, primary inputs and
   primary outputs now.

** TODO Proper representation of graph in Haskell
   When creating CDFG for case expression, I realized it is not as straightforward
   as I thought to describe a graph lazily in Haskell, considering CDFG is going
   to be changed for optimization in future.
   
   
** TODO Export the case expression
   
   Add a node to represent the ~case~ logic.

   The CDFG ~case~ logic is at a lower level than Haskell's ~case~
   expression. While Haskell's ~case~ expression involves constructor-matching,
   the CDFG ~case~ logic is merely value matching.
   
