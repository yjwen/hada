* TODO Github Issue #1: Trivial combinational logic [87%]

  Let's start from a very primitive Haskell function:
  #+BEGIN_SRC haskell
    abs :: Word -> Word -> Word
    abs a b | a < b = b - a
            | otherwise = a - b
  #+END_SRC

  Ideally, the Haskell function abs should be compiled to a Verilog
  module
  #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
  #+END_SRC

** DONE Print the desugared bindings of the Haskell source
   CLOSED: [2016-11-07 Mon 17:46]

   ~setSessionDynFlags~ is necessary if there is no dynamic flag to
   set because ~setSessionDynFlags~ will initialize library search
   path.  Otherwise, the GHC session will fail at finding dependent
   modules even as ~Prelude~.
   
   Related articles:
   * GHC compilation process:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain]]
   * The Core data:
     [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType]]

   How to extract the ~CoreExpr~ from the desugared module? ~mg_bind
   :: ModGuts -> CoreProgram~ return the binds. [[http://www.stephendiehl.com/posts/ghc_02.html][Dive Into GHC: The
   2nd article]] has some pretty examples about showing the core
   program.

   * ~HsSyn~ represents the AST parsed from source code.
   * ~coreModule~ extracts ~ModGuts~ from desugered module.
   * ~mg_binds~ return the core program from ~ModGuts~.
** DONE Get Verilog module name from function name
   CLOSED: [2016-11-21 Mon 17:40]

   Get module name ~abc~ from the binding of ~abc~.

   Reviewing GHC's code for pretty-printing ~CoreBind~.

   There is:
   #+BEGIN_SRC haskell
     pprCoreExpr :: OutputableBndr b => Expr b -> SDoc
   #+END_SRC
   to do pretty-printing for expressions. But pretty-printing ~Expr~
   doesn't show the function name.

   It is the binding variable ~v~ in a ~NonRec v e~ that shows the
   naming "abs". ~getOccString~ retrieve the string in ~v~.
** DONE Get the input output ports for the Verilog module
   CLOSED: [2016-12-13 Tue 18:15]
   
   Functions are represented as curried lambda expressions.
   So for ~abs~, its curried form is:
   #+BEGIN_SRC haskell
     abs = \a -> (\b -> case a < b of
                          True -> b - a
                          otherwise -> a - b)
   #+END_SRC
   And the lambda expressions are translated directly to ~Core.Lam v
   e~, where ~v~ is the variable and ~e~ is the expression.

   To get all the inputs of a function, the corresponding
   ~Core.Lam~ should be "de-curried", a process to strip off all the
   consequence ~Core.Lam~ expression, and return the list of binders
   of the stripped ~Core.Lam~ and the non-lambda expression it first
   find.

   Once the variable list is "de-curried" out, the bit-width 
   of the Verilog module inputs are determined by the type information
   of the variables. 
*** DONE Determine the bit-width for a binder ~Word~
    CLOSED: [2016-12-08 Thu 17:09]
    #+BEGIN_SRC haskell
    varType :: Var -> Kind
    #+END_SRC
    retrieve the type of the binder (~Kind~ is a synonym of ~Type~).
    
    #+BEGIN_SRC haskell
    splitTyConApp_maybe :: Type -> Maybe (TyCon, [Type])
    #+END_SRC
    try to split a type into a type constructor and the arguments to
    that constructor, by which type ~Word~ is split into a ~TyCon~ of
    ~Word~ and an empty argument list.

    We can determine how a ~TyCon~ is defined in Haskell, either by
    ~data~, ~type~ or any other constructs, by various predicates.
    For ~Word~, it is defined by ~data~ construct. Then ~isAlgTyCon~
    should return ~True~. 

    ~TyCon~ is an instance of class ~NamedThing~,
    so we can the name string by ~getOccString . getName~. For ~Word~,
    it should return "Word".

    When getting the string "Word", we know it is of type ~Word~, and 
    the bit width is ~finiteBitSize (0::Word)~.
    
   
*** DONE Determine the output type of a binding
    CLOSED: [2016-12-13 Tue 18:09]
    
    The type of the bound variable ~v~ in ~NonRec v e~ should be ~Word
    -> Word -> Word~, of kind ~* -> *~.

    The bound variable' type already gives the type of each input
    variable and the type of the returned value, namely the type of
    the output point of the Verilog module to be mapped to.

    We need to de-curry the type of kind ~* -> *~ to a list of types
    of kind ~*~ and return the input type list and the return type.

    There is:
    #+BEGIN_SRC haskell
      splitFunTys :: Type -> ([Type], Type)
    #+END_SRC
    doing such de-currying.
    
** DONE Data to represent the verilog netlist
   CLOSED: [2016-10-28 Fri 15:31]
   To design data types to represent a verilog module. The data
   should be an instance of class ~Outputable~, and can be
   pretty-printed into Verilog language.

   As the first step, the data type should be capable of representing
   the target Verilog content.
   #+BEGIN_SRC verilog
    module abs (a, b, out);
      input [0:63] a;
      input [0:63] b;
      output [0:63] out;
      assign out = (a < b) ? b - a : a - b;
    endmodule
   #+END_SRC

   Done with module ~Verilog~ (~Verilog.hs~.)

** DONE Data structure for control-data-flow-graph

   CLOSED: [2016-12-20 Tue 01:10]
   
   Mapping a case expression from Core.Expr to Verilog condition
   constructs is too complicated, considering the complex pattern
   matching syntax of Haskell is quite different from the syntax of
   various Verilog's conditional constructs.

   An intermediate data structure is necessary to isolate the mapping
   from Haskell case expression to conditional representation, and
   from conditional representation to Verilog conditional constructs.

   Such intermediate data structure is also useful for future optimization
   and scheduling of tasks.

   Take control-data-flow-graph as a start point.

   Finished a CDFG module to represent module, primary inputs and
   primary outputs now.

** DONE Proper representation of graph in Haskell
   CLOSED: [2017-01-11 Wed 16:48]
   When creating CDFG for case expression, I realized it is not as straightforward
   as I thought to describe a graph lazily in Haskell, considering CDFG is going
   to be changed for optimization in future.

   A question about graph representation in Haskell has been raised ([[http://stackoverflow.com/questions/9732084/how-do-you-represent-a-graph-in-haskell][here]]).
   Answers gave the following paper for reference.
   1. [[http://www.cs.tufts.edu/~nr/pubs/zipcfg.pdf][An Applicative Control-Flow Graph based on Huet's Zipper]]
   2. [[http://www.cs.tufts.edu/~nr/pubs/hoopl10.pdf][Hoopl: A Modular, Reusable Library for Dataflow Analysis and Transformation]]
   3. [[http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf][Inductive Graphs and Functional Graph Algorithms]]

     
   Read as a reference first.

   Article 1 and 2 are about control-flow graphs. The control-flow
   graph models the transfer of control between instructions and
   instruction sets. The concept of control-flow graph is not
   suitable for targetting RTL description, which is focusing on
   data-flows. However, the representation of the control-flow
   graph can be references of representing data-flow graphs.

   Article 1 is using a mutable representation of graphs, implemented
   by ML, as mentioned in article 2, which doesn't sounds suitable for
   Haskell implementation.

   Article 2 doesn't mention its implementation about the control-flow
   graph. But by its requiring nodes to have a label, it should be
   using an indirective representation, which maps labels to nodes.

   Article 3 is discussing an abstract inductive representation of
   graphs, either by the active pattern matching of ML, or mimiced by
   functions in Haskell. It also discussed several implementation
   of the underlying representation of graphs, using ML or Haskell.
   The representation of Haskell is an indirective one, where a node
   and its context (its predecessors and successos) are saved in
   a binary search tree.

   So indirective representation of graphs sounds a feasible approach
   for data-flow graphs. The fundamental problem for indirective
   representation is how to create a efficient data structure in
   Haskell that maps from labels to graph elements like nodes and
   edges.

   There are packages Data.Map and Data.Map.Strict that employ
   balanced binary search trees, and Data.HashMap and
   Data.HashMap.Strict that employ hash tables for mapping.

   The binary search trees in Data.Map is based on a paper
   [[http://groups.csail.mit.edu/mac/users/adams/BB/][Implementing Sets Efficiently in a Functional Language]]. Read the
   paper to grasp the ideas of sets in functional language.

   Reading done. The implementation is rather a straight one of
   balanced binary-search tree, a few things specific to functional
   language, which are:
   1. Tree balancing is based on sub-tree's node count, rather than
      depth or black-red marking, because sub-tree's node count
      doesn't change as frequently as depth or black-red marking in
      node-rotating, so most of the existing structure can be reused
      by the new balanced tree.
   2. Tree union, intersection and difference algorithms are optimized
      in flavour of functional language's lazy evaluation.

** DONE Revised representation of the data-flow-graph (DFG)
   CLOSED: [2017-01-14 Sat 23:46]
   
   Since the edge in control-flow-graph represents the jump of
   execution between code block, which is not a suitable concept for
   HDL. So the concept of DFG is used instead of CDFG.

   Choose to label both edges and nodes in the initial version of DFG,
   since it is the most flexible way.
      
** TODO Export the case expression
   
   Add a node to represent the ~case~ logic.

   The CDFG ~case~ logic is at a lower level than Haskell's ~case~
   expression. While Haskell's ~case~ expression involves constructor-matching,
   the CDFG ~case~ logic is merely value matching.
   
